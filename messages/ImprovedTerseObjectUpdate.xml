<?xml version="1.0"?>
<message xmlns="https://leoschwarz.github.io/opensim-protocol/util/MessageSchema.xsd" name="ImprovedTerseObjectUpdate" frequency_class="high" frequency_number="15" trusted="true" compression="unencoded">
    <block name="RegionData" quantity="single">
        <field name="RegionHandle" type="U64">
            <doc>TODO</doc>
        </field>
        <field name="TimeDilation" type="U16">
            <doc>TODO</doc>
        </field>
    </block>
    <block name="ObjectData" quantity="variable">
        <field name="Data" type="Variable 1">
            <doc>
                In sequential fashion the following fields are encoded.

                | bytes | field            | type        | description |
                | ----- | ---------------- | ----------- | ----------- |
                | 4     | localid          | u32         | should be the same as client.localid |
                | 1     | state            | u8          | TODO |
                | 1     | collision_exists | bool        | If 0 the next field is not specified (zero bytes), if 1 read as usual. |
                | 16?   | collision_plane  | Vector4 f32 | |
                | 12    | position         | Vector3 f32 | |
                | 6     | velocity         | Vector3 u16f [-128;128] | |
                | 6     | acceleration     | Vector3 u16f [-64;64] | |
                | 8     | rotation (theta) | Quat4 u16f [-1;1] | |
                | 6     | angular vel. (omega) | Vector3 u16f [-64;64] | |

                u16f: Means that the data is encoded as u16 (0-255), and is to be mapped
                      into the f32 range specified in square brackets afterwards.
                      Note that here we have to be careful that we set the value to zero,
                      if `abs(fval) &lt; (upper-lower) as f32 / 255`, so exact zeros can
                      be decoded.
            </doc>
        </field>
        <field name="TextureEntry" type="Variable 2">
            <doc>
                The first 16 bytes of the data are the texture_id.
                (TODO: If the length is shorter than this, the OpenMetaverse code does not
                       fail but actually indicates an absence of a texture.)

                Then follows the actual texture data:


                | bytes    | field | type | description |
                | -------- | 
                | 16       | default_texture| UUID | TextureID of the default texture. |
                | variable | face_textures | FBArray[UUID] | TextureIDs of the faces. |
                | variable | face_colors | FBArray[Color4



                Data is packed in so called face bitfields which can be decoded using
                the following helper function. Since multiple such bitfields are grouped
                in arrays (end is indicated by the helper function exists value equaling
                false) they are referred to as FBArray[type] above.

                TODO: Actually the encoding of arrays is a bit more intricate.

                ```text
                ReadFaceBitfield(in reader, out u32 face_bits) -> (bytes_read, exists) {
                    face_bits := 0;
                    bytes_read := 0;
                    do {
                        byte := reader.read_byte();
                        face_bits := (face_bits &lt;&lt; 7) | b &amp; 0x7f;
                        bytes_read += 7;
                    } while (b &amp; 0x80) != 0;
                    return (bytes_read, face_bits != 0);
                }
                ```


                
                TODO Inspect: OpenMetaverse/TextureEntry.cs FromBytes
            </doc>
        </field>
    </block>
    <doc>
        A terse object update is sent, when a transformation matrix, velocity or acceleration of an object changes, but the rest does not change.

    </doc>
    <sources>
        <source>Template File</source>
        <source>OpenMetaverse/ObjectManager.cs</source>
    </sources>
</message>
